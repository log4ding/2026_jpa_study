# 6장. 다양한 연관관계 매핑

> 스켈레톤: `java/` 또는 `kotlin/` 중 선택

---

## 숙제 1: @JoinColumn 토글
> 목표: @JoinColumn 유무에 따른 일대다 단방향 동작 차이 확인

### 시나리오
```
개발팀 ──┬── 홍길동
         └── 김철수
```
개발팀에 신입 2명(홍길동, 김철수)이 입사했습니다.
팀장이 팀원 명단을 관리하는 구조 (일대다 단방향: Team → Member).

### 실습

1. `homework1/Team`의 `@JoinColumn`이 주석 처리된 상태 확인
2. 테스트 작성:
   - Team "개발팀" 저장
   - Member "홍길동", "김철수" 저장
   - `team.getMembers().add(홍길동)`, `team.getMembers().add(김철수)` 호출
   - flush
3. Hibernate SQL 로그 확인 (어떤 테이블이 생기고, 어떤 쿼리가 나가는지)
4. `@JoinColumn(name = "team_id")` 주석 해제 후 다시 실행
5. SQL 로그 비교:
   - 조인 테이블이 생기는 경우는?
   - UPDATE 쿼리가 나가는 경우는?

```bash
./gradlew test --tests "homework.chapter_6.homework1.*"
```

---

## 숙제 2: 일대일 지연 로딩
> 목표: @OneToOne에서 LAZY 로딩 동작 확인

### 시나리오
```
홍길동 ──── 101번 사물함
```
헬스장 회원 홍길동에게 101번 사물함을 배정했습니다.
회원 테이블에 FK(locker_id)가 있습니다.

### 실습

1. `homework2/Member`에서 `@OneToOne`만 있는 상태 확인
2. 테스트 작성:
   - Locker "101번" 저장
   - Member "홍길동" 저장, `member.setLocker(locker)` 호출
   - flush/clear
   - Member 조회
   - `println("=== Member 조회 끝 ===")`
   - `member.getLocker().getName()` 호출
3. Hibernate SQL 로그에서 Locker SELECT가 println 전/후 언제 나오는지 확인
4. `@OneToOne(fetch = FetchType.LAZY)`로 수정 후 다시 실행
5. Locker SELECT 타이밍이 어떻게 바뀌는지 확인

```bash
./gradlew test --tests "homework.chapter_6.homework2.*"
```

---

## 숙제 3: 다대다 중간 엔티티
> 목표: 다대다 관계를 중간 엔티티로 풀어서 추가 속성 관리

### 시나리오
```
홍길동 ──┬── 주문1 (운동화 3개, 1/15)
         └── 주문2 (운동화 2개, 1/20)  ← 같은 상품 재주문!
```
쇼핑몰에서 홍길동이 운동화를 1월 15일에 3개 주문했습니다.
마음에 들어서 1월 20일에 2개 더 주문했습니다.

### 실습

1. `homework3/` 스켈레톤 코드 확인 (Member, Product, Order)
2. 테스트 작성:
   - Member "홍길동" 저장
   - Product "운동화" 저장
   - Order 2개 생성:
     - 주문1: 홍길동, 운동화, 3개, 1/15
     - 주문2: 홍길동, 운동화, 2개, 1/20
   - flush/clear
3. 확인:
   - Order 테이블에 2개 row가 저장됐는가?
   - 각 Order에 count, orderDate가 제대로 들어있는가?

```bash
./gradlew test --tests "homework.chapter_6.homework3.*"
```

---

## 보너스 (선택)

### 보너스 1: 역방향 지연 로딩
> 목표: 일대일에서 FK 없는 쪽의 LAZY 로딩 한계 확인

숙제 2에서 Member → Locker는 LAZY로 지연 로딩이 됐습니다.
이번엔 반대로 Locker → Member를 테스트해보세요.

1. `Locker`에 `@OneToOne(mappedBy="locker", fetch=LAZY)` 추가
2. 테스트 작성:
   - Locker, Member 저장 (Member가 FK 보유)
   - flush/clear
   - Locker 조회
   - `println("=== Locker 조회 끝 ===")`
   - `locker.getMember().getName()` 호출
3. Hibernate SQL 로그에서 Member SELECT가 println 전/후 언제 나오는지 확인

숙제 2와 똑같이 LAZY인데, 결과가 다르다면 왜 그럴까요?

---

### 보너스 2: 복합 키
> 목표: 복합 키로 비즈니스 제약(1인 1회 구매) 구현

```
숙제3:   일반 상품 → 재주문 가능 (대리 키)
보너스2: 이벤트 상품 → 1인 1회만 (복합 키)
```

창립기념 한정판은 1인 1회만 구매 가능합니다.

1. `@IdClass`로 (회원, 상품)을 복합 키로 하는 엔티티 생성
2. 테스트: 홍길동이 한정판을 2번 구매 시도
3. 두 번째 저장에서 어떤 일이 발생하는지 확인

---

### 보너스 3: 일대다 단방향 단점
> 목표: 일대다 단방향 vs 다대일 양방향 쿼리 효율 비교

숙제 1에서 INSERT/UPDATE 쿼리 수를 세어보세요.

1. 숙제 1 (일대다 단방향): Team 1개, Member 2개 저장 시 총 쿼리 몇 개?
2. 다대일 양방향으로 변경해서 같은 테스트 실행
3. 쿼리 수 비교: 어떤 차이가 있는가?
