# 1. JPA 소개

## 1.1 SQL 을 직접 다룰 때 발생하는 문제점
- 관계형 데이터베이스는 가장 대중적이고 신뢰할 만한 안전한 데이터 저장소
- 대부분 자바로 개발하는 애플리케이션은 관계형 데이터베이스를 저장소로 이용

### 1.1.1 반복, 반복 그리고 반복
- SQL을 직접 다룰 때의 문제점을 위해 회원 관리 기능을 개발해보자. 

```Java
public class Member {
    private String memberId;
    private String name;
}

public class MemberDao {
    public Member find(String memberId) {}
}
```

- 회원 조회하는 기능을 만들기 위한 순서

1. 회원 조회용 SQL 을 작성
```SQL
SELECT MEMBER_ID, NAME FROM MEMBER M WHERE MEMBER_ID = ?
```

2. JDBC API 를 사용해 SQL 실행
```Java
ResultSet rs = stmt.executeQuery(sql);
```

3. 조회 결과를 Member 객체로 매핑
```Java
String memberId = rs.getString("MEMBER_ID");
String name = rs.getString("NAME");

Member member = new Member();
member.setMemberId(memberId);
member.setName(name);
```

- 회원 등록 기능도 위와 같은 절차를 또다시 반복
- 결국 CRUD 개발 시에 너무 많은 SQL 과 JDBC API를 코드로 작성해야함

### 1.1.2 SQL에 의존적인 개발
- 회원 정보에 연락처 필드 하나를 추가해달라고 한다면 조회, 등록, 수정 코드들을 수정해야함
- 기능이 추가될수록 연관된 객체 수정같은 부분이 늘어나게 된다. 
- 그리고 버그가 생기면 SQL과 DAO 까지 전부 확인해봐야 되는 상황이 생긴다. 
- 이것은 진정한 의미의 계층 분할이 아니고 물리적으로 SQL과 JDBC API를 데이터 접근 계층에 숨기는 데 성공했을지는 몰라도 논리적으로는 엔티티와 강한 의존관계를 가지고 있다. 

### 1.1.3 JPA와 문제 해결
- JPA는 객체를 데이터베이스에 저장하고 관리할 떄 개발자가 직접 SQL을 작성하지 않고 JPA가 제공하는 API를 쓰면 된다. 

#### 저장기능
```Java
jpa.persist(member); // 저장
```

- 이 메소드를 호출하면 JPA가 객체와 매핑 정보를 보고 적절한 INSERT SQL을 생성하여 데이터베이스에 전달한다. 

#### 조회기능
```Java
String memberId = "helloId";
Member member = jpa.find(Member.class, memberId); // 조회
```

#### 수정기능
```Java
Member member = jpa.find(Member.class, memberId);
member.setName("이름변경"); // 수정
```

#### 연관된 객체 조회
```Java
Member member = jpa.find(Member.class, memberId);
Team team = member.getTeam(); // 연관된 객체 조회
```

## 1.2 패러다임의 불일치
- 객체와 관계형 데이터베이스는 지향하는 목적이 서로 다르므로 둘의 기능과 표현 방법이 다르다. 
- 객체 구조를 테이블 구조에 저장하는 데는 한계가 있다. (실제로 json text 형태로 많이 저장되고 있음)

### 1.2.1 상속
- 객체는 상속이라는 기능이 있지만 테이블은 없다. 
- 데이터베이스 모델링에서는 슈퍼타입 서브타입 관계를 사용하면 객체 상속과 가장 유사한 형태로 테이블 설계가 가능
- 이런 형태의 데이터를 저장하기 위해서는 부모 객체에서 부모 데이터만 꺼내 INSERT SQL 을 작성, 자식 데이터를 꺼내서 별도로 INSERT SQL을 작성해야한다. 조회도 마찬가지이다.  


#### JPA 와 상속
- 자바 컬렉션에 객체를 저장하듯 JPA에게 객체를 저장하면 된다. 
```Java
jpa.persist(album);
```

- JPA 는 다음 SQL을 실행해 객체를 두 테이블에 나눠 저장해준다.
- JPA 상속 매핑 전략을 선택할 수 있는 옵션
    - (개인적인 의견) JPA를 쓰게 된다면 개발자의 생산성 말고 또다른 장점이 있을까?
        - 부모/자식의 식별자 일관성
        - 다형성 조회 시 타입 안정성
        - 영속성 컨텍스트 기준의 객체 동일성 보장
        - 변경 비용 감소 (타입 변경이나 필드 변경에 코드 변경이 적음, 실수 발생 위험 낮출수 있음)

### 1.2.2 연관관계
- 객체는 참조를 사용해 다른 객체와 연관관계를 가지고 참조에 접근해 연관된 객체를 조회
- 테이블은 외래 키를 사용해 다른 테이블과 연관관계를 가지고 조인을 사용해 연관된 테이블을 조회

#### 객체를 테이블에 맞추어 모델링
```Java
public class Member {
    String id;          // MEMBER_ID 컬럼 사용
    Long teamId;        // TEAM_ID FK 컬럼
    String username;    // USERNAME 컬럼 사용
}

class Team {
    Long id;            // TEAM_ID PK 사용
    String name;        // NAME 컬럼 사용
}
```

- 이런 방식을 따르면 좋은 객체 모델링은 기대하기 어렵고 객체지향의 특징을 잃어버리게 된다. 

#### 객체지향 모델링

```Java
class Member {
    String id;          // MEMBER_ID 컬럼 사용
    Team team;          // 참조로 연관관계를 맺는다. 
    String username;    // USERNAME 컬럼 사용

    Team getTeam(){
        return team;
    }
}

class Team {
    Long id;            // TEAM_ID PK 사용
    String name;        // NAME 컬럼 사용
}
```

- 객체 모델은 외래키가 필요없고 단지 참조만 있으면 된다. 

- *(개인적인 의견)*
    - 보통 실무에서는 id 로 연관관계를 표현하지 않고 아래 객체지향 모델링을 그대로 쓰면서 JOIN 쿼리로 한방에 해결하게 되어 있음. -> 결과적으로 JPA 의 장점으로 이야기 된 부분이 약간의 허점이 있어보임.
    - 그렇다면 JPA를 쓰는 진짜 장점은 뭘까?
        - 도메인 규칙을 타입으로 강제 (SQL 에서는 JOIN으로 실수가 발생할 수 있음)
        - 관계 자체가 타입으로 고정 -> 잘못된 관계 대입 불가
        - 도메인 규칙을 모델에 가둠
        - Command(쓰기) -> JPA 엔티티 + 연관관계를 많이 씀
        - Query(읽기) -> JOIN + DTO도 많이 씀

### 1.2.3 객체 그래프 탐색
- 객체에서 회원이 소속된 팀을 조회할 때는 다음처럼 참조를 사용해 연관된 팀을 찾으면 되는데, 이것을 객체 그래프 탐색이라 한다. 
```Java
member.getOrder().getOrderItem();       // 자유로운 객체 그래프 탐색
```

- 데이터베이스에서는 다음과 같은 객체 그래프 탐색이 쉽지 않다. 
- SQL 을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있을지 정해진다. 

```Java
class MemberService {
    public void process() {
        Member member = memberDao.find(memberId);
        member.getTeam();       // member -> team 객체 그래프 탐색이 가능한가?
        member.getOrder().getDelivery();     // ??
    }
}
```

- Order에 Delivery를 탐색할 수 있을지는 코드만 보고는 예측할 수 없다. (실제 Delivery 객체가 있는지는 쿼리를 만든 사람만 알고 있다.)
- *(개인적인 의견)*
    - left join 일 경우 null일 수도 있을텐데 라는 의문점이 생김
    - null의 의미가 달라짐. 
        - JPA를 썼을 때 null인 경우엔 연관관계가 있는 상태에서 left join 인 경우 매핑된 정보가 없다는 도메인적 의미로 고정될 수 있음
        - SQL로 썼을 때는 연관관계가 있는지를 SQL을 봐야 알 수 있음. null의 의미가 두가지가 됨. 연관관계인지 여부, 매핑된 정보가 있는지 여부 

#### JPA와 객체 그래프 탐색
- JPA는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL을 실행한다. 실제 객체를 사용하는 시점까지 로딩을 미룬다하여 이를 *지연로딩* 이라고 한다. > 즉시 로딩이 있을 수도 있음

### 1.2.4 비교
- 데이터베이스는 기본 키의 값으로 각 row 를 구분, 객체는 동일성(identity) 와 동등성(equality) 라는 비교 방법이 있다. 

```Java
class MemberDao {
    public Member getMember(String memberId) {
        String sql = "SELECT * FROM MEMBER WHERE MEMBER_ID = ?";

        // JDBC API, SQL 실행
        return new Member();
    }
}

String memberId = "100";
Member member1 = memberDao.getMember(memberId);
Member member2 = memberDao.getMember(memberId);

member1 == member2; // false
```

- 데이터베이스의 같은 로우를 조회할 때마다 같은 인스턴스를 반환하도록 구현하는 문제는 쉽지 않음

#### JPA와 비교
- 아래 내용은 같은 영속성 컨텍스트 안에서만 가능 
```Java
String memberId = "100";
Member member1 = jpa.find(Member.class, memberId);
Member member2 = jpa.find(Member.class, memberId);

member1 == member2; // true
```

- *(개인적인 의견)*
    - 동일 PK의 다른 인스턴스를 쓸 경우 
    ```Java
    Member m1 = findMember();
    Member m2 = findMember();

    m1.setName("A");    // m2 는 변경 사실 모름, 상태 분산 발생
    ```
    - JPA의 경우 
        - 상태 변경 지점이 하나가 됨. 
        - Dirty checking 가능 
        - flush 시점에 변경 SQL 자동 생성

## 1.3 JPA란 무엇인가?
- JPA (JAVA Persistence API) 는 자바 진영의 ORM 기술 표준
    - 현재는 jakarta Persistence 로 이름이 변경됨
- ORM (Object-Relational Mapping) 은 객체와 관계형 데이터베이스를 매핑한다는 뜻

### 1.3.1 JPA 소개
- JPA는 자바 ORM 기술에 대한 API 표준 명세
- 하이버네이트를 구현 프레임워크로 사용하는 JPA 2.1 버전에 대한 설명임
    - 현재는 3.x 까지 버전이 나옴, 여전히 하이버네이트 구현을 많이 씀

### 1.3.2 왜 JPA를 사용해야 하는가?
- 생산성
- 유지보수
- 패러다임 불일치 해결
- 성능
- 데이터 접근 추상화와 벤더 독립성
- 자바 진영의 표준

- *(개인적인 의견)*
    - 한방 쿼리 VS JPA
        - 예전부터 성능에 대해 여러 이야기들이 많았음
        - 현재는 역할 분리를 하고 있는 추세 
            - 쓰기 (Command)
                - JPA Entiry
                - 연관관계 최소
                - Dirty Checking 활용
            - 조회 (Query)
                - JPQL / QueryDSL / Native SQL
                - DTO Projection (조회 목적에 맞는 모양으로 바로 뽑아오자 는 접근)
                - 경우에 따라 한방쿼리