# 2장 JPA 시작

## 2.4 객체 매핑 시작

```SQL
CREATE TABLE MEMBER (
    ID VARCHAR(255) NOT NULL,
    NAME VARCHAR(255),
    AGE INTEGER,
    PRIMARY KEY (ID)
)
```

```kotlin
@Entity
@Table(name = "MEMBER")
class Member(
    @Id
    @Column(name = "ID")
    var id: String = "",

    @Column(name = "NAME")
    var name: String? = null,

    @Column(name = "AGE")
    var age: Int? = null
)
```

- @Entity
    - 이 클래스가 테이블과 매핑한다고 지정

- @Table
    - 엔티티 클래스에 매핑할 테이블 정보 지정

- @Id
    - 엔티티 클래스의 필드를 테이블 기본 키 (Primary Key) 에 매핑

- @Column
    - 필드를 컬럼에 매핑

## 2.5 persistence.xml 설정
- Spring boot 를 쓰게 된다면 이 설정은 사용하지 않아도 된다. 
- 대신 application.yaml 에 기재해서 사용한다. 

```YAML
spring:
  application:
    name: {PROJECT_NAME}
  datasource:
    url: jdbc:h2:mem:{PROJECT_NAME};DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    username: sa
    password: ""
    driver-class-name: org.h2.Driver
  h2:
    console:
      enabled: true
  jpa:
    hibernate:
      ddl-auto: none
  sql:
    init:
      mode: always
```

### 2.5.1 데이터베이스 방언(Dialect)
- JPA는 특정 데이터베이스에 종속적이지 않은 기술, 다른 데이터베이스로 손쉽게 교체 가능

## 2.6 애플리케이션 개발
- main 을 쓰지 않고 CommandRunner 를 사용함.

```kotlin
@Component
class CommandRunner(
    private val entityManagerFactory: EntityManagerFactory
) : CommandLineRunner {
    override fun run(vararg args: String) {
        val em = entityManagerFactory.createEntityManager()
        val tx = em.transaction

        try {
            tx.begin()
            logic(em)
            tx.commit()
        } catch (ex: Exception) {
            if (tx.isActive) {
                tx.rollback()
            }
            throw ex
        } finally {
            em.close()
        }
    }

    private fun logic(em: EntityManager) {
        // 
    }
}
```

### 2.6.1 엔티티 매니저 설정
- 엔티티 매니저 팩토리 생성
    - JPA 를 사용하려면 엔티티 매니저 팩토리를 생성해야 한다. 
    - 엔티티 매니저 팩토리는 애플리케이션 전체에서 딱 한번만 생성하고 공유해서 사용해야한다. 
- 엔티티 매니저 생성
    - 엔티티 매니저를 사용해 엔티티를 데이터베이스에 등록/수정/삭제/조회할 수 있다. 
    - 엔티티 매니저는 데이터베이스 커넥션과 밀접한 관계가 있으므로 스레드 간 공유하거나 재사용하면 안된다. 
- 종료
    - 엔티티 매니저는 반드시 종료해야함
    - 엔티티 매니저 팩토리도 종료해야함

- *(개인적인 의견)*
    - Spring Data JPA 를 쓸 경우 Repository 로 대부분 대신한다. 
    - EntityManager 를 직접 써야하는 경우
        - 복잡한 동적 쿼리/배치 작업에서 직접 flush/clear 조절이 필요한 경우
        - 표준 JPA API를 직접 써야 하는 학습/테스트 목적
        - 커스텀 리포지토리 구현에서 JPA 내부 기능을 쓰고 싶은 경우

    - Repository 를 직접 쓰는 경우
    ```kotlin
    interface MemberRepository : JpaRepository<Member, String>

    @Component
    @Order(1)
    class RepositoryRunner(
        private val memberRepository: MemberRepository
    ) : CommandLineRunner {
        @Transactional
        override fun run(vararg args: String) {
            val member = Member(id = "id1", name = "Alice", age = 25)
            memberRepository.save(member)

            member.age = 40
            memberRepository.saveAndFlush(member)

            val found = memberRepository.findById("id1").orElse(null)
            println(found)

            val members = memberRepository.findAll()
            val memberSize = members.size
            println(memberSize)

            memberRepository.delete(member)
        }
    }
    ```

### 2.6.2 트랜잭션 관리
- JPA 를 사용한다면 트랜잭션 안에서 항상 데이터를 변경해야한다. 
- *(개인적인 의견)* 
    - Repository 를 쓸 경우 트랜잭션은 보통 Service 로직에서 @Transactional 로 묶는 방식을 이용

### 2.6.3 비즈니스 로직
- 데이터베이스에 등록, 수정, 삭제, 조회를 한다. 

```kotlin
private fun logic(em: EntityManager) {
    val member = Member(id = "id1", name = "Alice", age = 25)
    em.persist(member)

    member.age = 40

    val found = em.find(Member::class.java, "id1")
    println("findMember = ${found.name}, age = ${found.age}")

    val members = em.createQuery("select m from Member m", Member::class.java)
        .resultList
    val memberSize = members.size
    println("member.size = ${memberSize}")

    em.remove(member)
}
```

### 2.6.4 JPQL
- 하나 이상의 회원 목록을 조회하는 다음 코드를 자세히 보자,

```kotlin
val members = em.createQuery("select m from Member m", Member::class.java)
        .resultList
```

- JPA를 사용하면 개발자는 엔티티 객체를 중심으로 개발하고 데이터베이스에 대한 처리는 JPA 에게 맡겨야 한다. 
- JPA 는 JPQL이라는 쿼리 언어로 내부적으로 해결한다. 

- JPQL은 엔티티 객체를 대상으로 쿼리한다. 클래스와 필드를 대상으로 쿼리한다. 
- SQL은 데이터베이스 테이블을 대상으로 쿼리한다. 

- JPQL은 데이터베이스 테이블을 전혀 알지 못한다. > JPA는 JPQL을 분석해 적절한 SQL 을 만들어 데이터를 조회한다. 

```SQL
-- JPQL
select m from member m

-- SQL
SELECT M.ID, M.NAME, M.AGE FROM MEMBER M
```