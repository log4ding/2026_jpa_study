# 8장 프록시와 연관관계 관리
- 프록시와 즉시로딩, 지연로딩
- 영속성 전이와 고아 객체

## 8.1 프록시
- 엔티티를 조회할 때 연관된 엔티티들이 항상 사용되는 것은 아니다. 

```java
@Entity
public class Member {
    private String username;

    @ManyToOne
    private Team team;
}

@Entity
public class Team {
    private String name;
}

public void printUserAndTeam(String memberId) {
    Member member = em.find(Member.class, memberId);
    Team team = member.getTeam();
    System.out.println("회원이름 :" + member.getUsername());
    System.out.println("소속팀:" + team.getName());
}

public void printUser(String memberId) {
    Member member = em.find(Member.class, memberId);
    System.out.println("회원이름 :" + member.getUsername());
}
```

- 회원 정보만 사용할 경우 team 까지 조회되는 것은 효율적이지 않음
- JPA 에서는 이런 문제를 해결하기 위해 엔티티가 실제 사용될 때까지 지연 로딩을 제공함.

### 8.1.1 프록시 기초
- 프록시 특징
    - 프록시 클래스는 실제 클래스를 상속 받아 만들어지므로 실제 클래스와 겉 모양이 같음
    - 프록시 객체는 실제 객체에 대한 참조(target)를 보관.
- 프록시 객체의 초기화
    - 프록시 객체는 member.getName() 처럼 실제 사용될 때 데이터베이스를 조회해서 실제 엔티티 객체를 생성하는데 이것을 프록시 객체의 초기화 라고 함.

- 결론 (프록시의 특징)
    - 프록시 객체는 처음 사용할 때 한번만 초기화 됨
    - 프록시 객체를 초기화 한다고 프록시 객체가 실제 엔티티로 바뀌지 않음
    - 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크 시에 주의해야함
    - 영속성 컨텍스트에 이미 엔티티가 있으면 프록시가 아닌 실제 엔티티를 반환함
    - 초기화는 영속성 컨텍스트의 도움을 받아야 가능함, 준영속 상태의 프록시를 초기화 하면 문제가 발생

### 8.1.2 프록시와 식별자
- 엔티티를 프록시로 조회할 때 식별자(PK) 값을 파라미터로 전달하는데 프록시 객체는 이 식별자 값을 보관한다. 
- 프록시는 다음 코드처럼 연관관계를 설정할 때 유용하게 사용할 수 있다. 

```java
Member member = em.find(Member.class, "member1");
Team team = em.getReference(Team.class, "team1");
member.setTeam(team);
```

#### 8.1.3 프록시 확인
- JPA 가 제공하는 PersistenceUnitUtil.isLoaded(Object entity) 메소드를 사용하면 프록시 인스턴스의 초기화 여부를 확인할 수 있다. 
- 프록시의 강제 초기화
    - 하이버네이트의 initialize() 메소드를 사용하면 프록시를 강제로 초기화할 수 있다. 
    - JPA 에서는 초기화 메소드가 없음. 강제로 초기화 하려면 member.getName() 처럼 프록시의 메소드를 직접 호출하면 된다. 

## 8.2 즉시 로딩과 지연 로딩
- 프록시 객체는 주로 연관된 엔티티를 지연로딩할 때 사용된다. 

```java
Member member = em.find(Member.class, "member1");
Team team = member.getTeam();
System.out.println(team.getName());
```

- 즉시 로딩 : 엔티티를 조회할 때 연관된 엔티티도 함께 조회한다.
    - @ManyToOne(fetch = FetchType.EAGER)
- 지연 로딩 : 연관된 엔티티를 실제 사용할 때 조회한다.
    - @ManyToOne(fetch = FetchType.LAZY)

### 8.2.1 즉시 로딩
- JPA 구현체는 즉시 로딩을 최적화 하기 위해 가능하면 조인 쿼리를 사용한다.

```SQL
SELECT
    M.MEMBER_ID AS MEMBER_ID,
    M.TEAM_ID AS TEAM_ID,
    M.USERNAME AS USERNAME,
    T.TEAM_ID AS TEAM_ID,
    T.NAME AS NAME
FROM
    MEMBER M LEFT OUTER JOIN TEAM T
        ON M.TEAM_ID = T.TEAM_ID
WHERE
    M.MEBER_ID = 'member1'
```

#### Null 제약조건과 JPA 조인 전략
- 즉시로딩 사용시에 outer join 을 사용한 것을 유심히 봐야한다.
- 팀에 소속되지 않은 회원이 있을 가능성이 있다. 
- JPA 는 보통 조인을 outer join 을 이용하게 된다. inner join 을 사용하게 하려면 어떻게 해야할까?
    - 외래 키에 NOT NULL 제약조건을 설정하면 값이 있는 것을 보장한다. 

```java
@Entity
public class Member {
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "TEAM_ID", nullable = false)
    private Team team;
}
```

- nullable 설정에 따른 조인 전략
    - @JoinColumn(nullable = true) : Null 허용, outer 조인 사용
    - @JoinColumn(nullable = false) : Null 허용하지 않음, inner 조인 사용
    - @ManyToOne.optional = false 로 해도 inner 조인을 사용한다. 

```java
@Entity
public class Member {
    @ManyToOne(fetch = FetchType.EAGER, optional = false)
    @JoinColumn(name = "TEAM_ID", nullable = false)
    private Team team;
}
```

### 8.2.2 지연 로딩
```java
@Entity
public class Member {
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "TEAM_ID", nullable = false)
    private Team team;
}

Member member = em.find(Member.class, "member1");
Team team = member.getTeam();
team.getName();     // 팀 객체 실제 사용
```

- 이 프록시 객체는 실제 사용될 때까지 데이터 로딩을 미룬다. 그래서 지연 로딩이라 한다. 


### 8.2.3 즉시 로딩, 지연 로딩 정리
- 지연로딩 : 연관된 엔티티를 프록시로 조회한다. 프록시를 실제 사용할 때 초기화 하면서 데이터베이스를 조회
- 즉시로딩 : 연관된 엔티티를 즉시 조회한다. 하이버네티으는 가능한 SQL 조인을 사용해 한번에 조회

## 8.3 지연로딩 활용

```java
@Entity
public class Member {
    @Id
    private String id;
    private String username;
    private Integer age;

    @ManyToOne(fetch = FetchType.EAGER)
    private Team team;

    @OneToMany(mappedBy = "member", fetch = FetchType.LAZY)
    private List<Order> orders;
}
```

- 회원과 주문내역은 LAZY, team 은 즉시 로딩으로 설정한다. 
- 회원 엔티티 조회 시에 SQL을 살펴보자

```SQL
SELECT
    MEMBER.ID AS MEMBERID,
    MEMBER.AGE AS AGE,
    MEMBER.TEAM_ID AS TEAM_ID,
    MEMBER.USERNAME AS USERNAME,
    TEAM.ID AS TEAMID,
    TEAM.NAME AS NAME
FROM
    MEMBER MEMBER
LEFT OUTER JOIN
    TEAM TEAM ON MEMBER.TEAM_ID = TEAM1_.ID
WHERE 
    MEMBER0_.ID = 'member1'
```

- 회원과 주문내역은 LAZY 로 설정했으므로 결과는 프록시로 조회한다. 그래서 SQL 에 나타나지 않는다. 

### 8.3.1 프록시와 컬렉션 래퍼
- 엔티티를 지연로딩하면 프록시 객체를 사용해 지연로딩을 수행하지만, 주문내역 같은 컬렉션은 컬렉션 래퍼가 지연 로딩을 처리해준다. 
- member.getOrders() 를 호출해도 컬렉션은 초기화 되지 않는다. 컬렉션은 member.getOrders().get(0) 처럼 컬렉션에서 실제 데이터를 조회할 때 데이터베이스를 조회해서 초기화한다. 

- **(추가로 찾아봄)**
    - size() 를 호출할 때 어떤 쿼리가 나갈까? -> 전체 SELECT 

### 8.3.2 JPA 기본 페치 전략
- @ManyToOne, @OneToOne : EAGER
- @OneToMany, @ManyToMany : LAZY

- 처음에 모든 연관관계에 지연 로딩을 사용한 뒤에 꼭 필요한 곳에 즉시 로딩을 사용하도록 최적화 하는 것을 저자는 추천함. 

### 8.3.3 컬렉션에 FetchType.EAGER 사용 시 주의점
- 컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않는다. 
    - 컬렉션과 조인은 일대다 조인. 
    - SQL 실행 결과가 n x m 이 되면서 너무 많은 데이터를 반환할 수 있고 애플리케이션 성능이 저하될 수 있다. 

- 컬렉션 즉시 로딩은 항상 외부 조인을 사용한다. 
    - JPA 는 일대다 관계를 즉시로딩할 때 항상 외부 조인을 사용한다. 

## 8.4 영속성 전이: CASCADE 
- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티를 함께 영속 상태로 만들고 싶으면 영속성 전이(transitive persistence) 기능을 사용하면 된다. 
- JPA 는 CASCADE 옵션으로 영속성 전이를 제공한다. 

```java
@Entity
public class Parent {
    @Id @GeneratedValue
    private Long id;

    @OneToMany(mappedBy = "parent")
    private List<Child> children = new ArrayList<Child>();
}

@Entity
public class Child {
    @Id @GeneratedValue
    private Long id;

    @ManyToOne
    private Parent parent;
}

private static void saveNoCascade(EntityManager em) {
    Parent parent = new Parent();
    em.persist(parent);

    Child child1 = new Child();
    child1.setParent(parent);
    parent.getChildren().add(child1);
    em.persist(child1);

    Child child2 = new Child();
    child2.setParent(parent);
    parent.getChildren().add(child2);
    em.persist(child2);
}
```

- JPA 에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 한다. 


### 8.4.1 영속성 전이: 저장
```java
@Entity
public class Parent {
    @OneToMany(mappedBy = "parent", cascade = CascadeType.PERSIST)
    private List<Child> children = new ArrayList<Child>();
}
```
- 부모 영속화 할 때 자식도 같이 영속화하라고 cascade persist 옵션을 적용함.

```java
private static void saveWithCascade(EntityManager em) {
    Child child1 = new Child();
    Child child2 = new Child();

    Parent parent = new Parent();
    child1.setParent(parent);
    child2.setParent(parent);

    parent.getChildren().add(child1);
    parent.getChildren().add(child2);

    // 부모, 연관된 자식 전부 저장
    em.persist(parent);
}
```

- 영속성 전이는 엔티티를 영속화 할 때 연관된 엔티티도 같이 영속화 하는 편리함을 제공할 뿐 연관관계와 아무런 관련이 없다. 

### 8.4.2 영속성 전이: 삭제
- 부모와 자식 엔티티를 전부 제거하려면 각각의 엔티티를 하나씩 제거해야한다. 
- 그러나 cascade 옵션을 사용하면 연관된 자식 엔티티도 함께 삭제할 수 있다. 
- CascadeType.REMOVE 

### 8.4.3 CASCADE 의 종류
```java
public enum CascadeType {
    ALL,
    PERSIST,
    MERGE,
    REMOVE,
    REFRESH,
    DETACH
}
```

## 8.5 고아객체 (orphan)
- JPA 는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공하는데 이것을 고아객체 제거라고 한다.
- 부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제되도록 해보자

```java
@Entity
public class Parent {
    @Id @GeneratedValue
    private Long id;

    @OneToMany(mappedBy = "parent", orphanRemoval = true)
    private List<Child> children = new ArrayList<Child>();
}

Parent parent1 = em.find(Parent.class, id);
parent1.getChildren().remove(0);        // 자식 엔티티를 컬렉션에서 제거
```

- 실행 SQL 은 `DELETE FROM CHILD WHERE ID=?` 이다. 
- 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능

## 8.6 영속성 전이 + 고아 객체, 생명주기
- CascadeType.ALL + orphanRemoval = true 를 동시에 사용하면 어떻게 될까?
- 일반적으로 엔티티는 persist 로 영속화 되고 remove 로 제거된다. 
- 엔티티가 스스로 생명주기를 관리한다는 뜻이다. 
- 두 옵션 모두 활성화 할 경우 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있다.  