# 6장. 다양한 연관관계 매핑
- 다중성
    - 다대일 (@ManyToOne)
    - 일대다 (@OneToMany)
    - 일대일 (@OneToOne)
    - 다대다 (@ManyToMany)

## 6.1 다대일
- 객체 양방향 관계에서 연관관계의 주인은 항상 다 쪽이다. 

### 6.1.1 다대일 단방향 [N:1]

```java
@Entity
public class Member {
    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    private String username;

    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team;
}

@Entity
public class Team {
    @Id @GeneratedValue
    @Column(name = "TEAM_ID")
    private Long id;

    private String name;
}
```

- Member.team 필드로 회원 테이블의 TEAM_ID 외래키를 관리

### 6.1.2 다대일 양방향 [N:1, 1:N]

```java
@Entity
public class Member {
    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    private String username;

    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team;

    public void setTeam(Team team) {
        this.team = team;

        if (!team.getMembers().contains(this)) {
            team.getMembers().add(this);
        }
    }
}

@Entity
public class Team {
    @Id @GeneratedValue
    @Column(name = "TEAM_ID")
    private Long id;

    private String name;

    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<Member>();

    public void addMember(Member member) {
        this.members.add(member);
        if (member.getTeam() != this) {
            member.setTeam(this);
        }
    }
}
```
- 양방향은 외래 키가 있는 쪽이 연관관계 주인
- 양방향 연관관계는 항상 서로를 참조해야 한다. 

## 6.2 일대다
### 6.2.1 일대다 단방향 [1:N]

```java
@Entity
public class Team {
    @Id @GeneratedValue
    @Column(name = "TEAM_ID")
    private Long id;

    private String name;

    @OneToMany
    @JoinColumn(name = "TEAM_ID")
    private List<Member> members = new ArrayList<Member>();
}

@Entity
public class Member {
    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    private String username;
}
```

- 일대다 단방향 매핑의 단점
    - 외래키가 다른 테이블에 있는 것
    - 다른 테이블에 외래키가 있다면 연관관계 처리를 위한 UPDATE SQL을 추가로 실행해야한다. 

```java
public void testSave() {
    Member member1 = new Member("member1");
    Member member2 = new Member("member2");

    Team team1 = new Team("team1");
    team1.getMembers().add(member1);
    team1.getMembers().add(member2);

    em.persist(member1);        // INSERT-member1
    em.persist(member2);        // INSERT-member2
    em.persist(team1);          // INSERT-team1, UPDATE-member1.fk, UPDATE-member2.fk

    transaction.commit();
}
```

- 결론: 다대일 양방향 매핑을 이용하자!

### 6.2.2 일대다 양방향 [1:N, N:1]
- 일대다 양방향 매핑은 존재하지 않는다. 
- 양방향 매핑에서 @OneToMany는 연관관계의 주인이 될 수 없다. 

```java
@Entity
public class Team {
    @Id @GeneratedValue
    @Column(name = "TEAM_ID")
    private Long id;

    private String name;

    @OneToMany
    @JoinColumn(name = "TEAM_ID")
    private List<Member> members = new ArrayList<Member>();
}

@Entity
public class Member {
    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    private String username;

    @ManyToOne
    @JoinColumn(name = "TEAM_ID", insertable = false, updatable = false)
    private Team team;
}
```

## 6.3 일대일 [1:1]
- 주 테이블에 외래키
- 대상 테이블에 외래키

### 6.3.1 주 테이블에 외래키

#### 단방향
```java
@Entity
public class Member {
    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    private String username;

    @OneToOne
    @JoinColumn(name = "LOCKER_ID")
    private Locker locker;
}

@Entity
public class Locker {
    @Id @GeneratedValue
    @Column(name = "LOCKER_ID")
    private Long id;

    private String name;
}
```

#### 양방향
```java
@Entity
public class Member {
    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    private String username;

    @OneToOne
    @JoinColumn(name = "LOCKER_ID")
    private Locker locker;
}

@Entity
public class Locker {
    @Id @GeneratedValue
    @Column(name = "LOCKER_ID")
    private Long id;

    private String name;

    @OneToOne(mappedBy = "locker")
    private Member member;
}
```

### 6.3.2 대상 테이블에 외래 키
#### 단반향
```java
@Entity
public class Member {
    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    private String username;

    @OneToOne(mappedBy = "member")
    private Locker locker;
}

@Entity
public class Locker {
    @Id @GeneratedValue
    @Column(name = "LOCKER_ID")
    private Long id;

    private String name;

    @OneToOne
    @JoinColumn(name = "MEMBER_ID")
    private Member member;
}
```

- 프록시와 지연로딩은 8장에서 다시...

## 6.4 다대다 [N:N]
- 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없다. 
- 중간에 연결 테이블을 생성해야한다. (member_product) 

### 6.4.1 다대다: 양방향

```java
@Entity
public class Member {
    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    private String username;

    @ManyToMany
    @JoinTable(name = "MEMBER_PRODUCT",
        joinColumns = @JoinColumn(name = "MEMBER_ID"),
        inverseJoinColumns = @JoinColumn(name = "PRODUCT_ID"))
    private List<Product> products = new ArrayList<Product>();
}

@Entity
public class Product {
    @Id @Column(name = "PRODUCT_ID")
    private String id;

    private String name;
}
```

- 회원 엔티티와 상품 엔티티를 @ManyToMany로 매핑했다. 

- @JoinTable.name : 연결 테이블을 지정
- @JoinTable.joinColumns : 현재 방향인 회원과 매핑할 조인 컬럼 정보 지정
- @JoinTable.inverseJoinColumns : 반대 방향인 상품과 매핑할 조인 컬럼 정보 지정

```java
// 저장 예제
public void save() {
    Product productA = new Product();
    productA.setId("productA");
    productA.setName("상품A");
    em.persist(productA);

    Member member1 = new Member();
    member1.setId("member1");
    member1.setUsername("회원1");
    member1.getProducts().add(productA);
    em.persist(member1);
}

// 탐색 예제
public void find() {
    Member member = em.find(Member.class, "member1");
    List<Product> products = member.getProducts();
    for (Product product: products) {
        System.out.println("product.name = " + product.getName());
    }
}
```

- 실제 SQL

```SQL
SELECT * FROM MEMBER_PRODUCT MP
INNER JOIN PRODUCT P ON MP.PRODUCT_ID = P.PRODUCT_ID
WHERE MP.MEMBER_ID = ?
```

### 6.4.2 다대다: 양방향
- 역방향도 @ManyToMany를 이용한다. 

```java
@Entity
public class Product {
    @Id @Column(name = "PRODUCT_ID")
    private String id;

    private String name;

    @ManyToMany(mappedBy = "product")
    private List<Member> members;
}

// 추가
public void addProduct(Product product) {
    products.add(product);
    product.getMembers().add(this);
}

// 역방향 탐색
public void findInvers() {
    Product product = em.find(Product.class, "productA");
    List<Member> members = product.getMembers();
    for (Member member : members) {
        System.out.println("member = " + member.getUsername());
    }
}
```

### 6.4.3 다대다: 매핑의 한계와 극복, 연결 엔티티 사용
- @ManyToMany 를 사용하면 연결 테이블을 자동으로 처리해주므로 도메인 모델이 단순해지고 편리하지만 실무에서 사용하기엔 한계가 있다. 
- 매핑 테이블에 주문 날짜와 주문량을 추가하면 더이상 @ManyToMany를 이용할 수 없다. 

```java
@Entity
public class Member {
    @Id @Column(name = "MEMBER_ID")
    private String id;

    @OneToMany(mappedBy = "member")
    private List<MemberProduct> memberProducts;
}

@Entity
public class Product {
    @Id @Column(name = "PRODUCT_ID")
    private String id;

    private String name;
}

@Entity
@IdClass(MemberProductId.class)
public class MemberProduct {
    @Id
    @ManyToOne
    @JoinColumn(name = "MEMBER_ID")
    private Member member;

    @Id
    @ManyToOne
    @JoinColumn(name = "PRODUCT_ID")
    private Product product;

    private int orderAmount;
}

public class MemberProductId implements Serializable {
    private String member;
    private String product;

    @Override
    public boolean equals(Object o) {}

    @Override
    public int hashCode() {}
}
```

- 복합 기본키
    - 회원상품 엔티티는 기본 키가 MEMBER_ID 와 PRODUCT_ID 로 이루어진 복합 기본키
    - 복합키는 별도 식별자 클래스를 만들어야한다.
    - Serializable 을 구현해야한다.
    - equals 와 hashCode 가 있어야한다.
    - 기본 생성자가 있어야한다.
    - 식별자 클래스는 public 이어야 한다.
    - @idClass 쓰는 것 외에 @EmbeddedId 를 사용하는 방법도 있다. 

- 식별 관계
    - 회원 상품은 회원과 상품의 기본 키를 받아서 자신의 기본 키로 사용
    - 이것을 식별관계 라고 한다. 

```java
// 저장하는 코드
public void save() {
    Member member1 = new Member();
    member1.setId("member1");
    member1.setUsername("회원1");
    em.persist(member1);

    Product productA = new Product();
    productA.setId("productA");
    productA.setName("상품1");
    em.persist(productA);

    MemberProduct memberProduct = new MemberProduct();
    memberProduct.setMember(member1);
    memberProduct.setProduct(productA);
    memberProduct.setOrderAmount(2);

    em.persist(memberProduct);
}

// 조회하는 코드
public void find() {
    MemberProductId memberProductId = new MemberProductId();
    memberProductId.setMember("member1");
    memberProductId.setProduct("productA");

    MemberProduct memberProduct = em.find(MemberProduct.class, memberProductId);

    Member member = memberProduct.getMember();
    Product product = memberProduct.getProduct();
}
```

### 6.4.4 다대다: 새로운 기본 키 사용
- MemberProduct > Order 로 이름을 바꾼다. 

```java
@Entity
public class Order {
    @Id @GeneratedValue
    @Column(name = "ORDER_ID")
    private Long id;

    @ManyToOne
    @JoinColumn(name = "MEMBER_ID")
    private Member member;

    @ManyToOne
    @JoinColumn(name = "PRODUCT_ID")
    private Product product;

    private int orderAmount;
}

@Entity
public class Member {
    @Id @Column(name = "MEMBER_ID")
    private String id;
    private String username;

    @OneToMany(mappedBy = "member")
    private List<Order> orders = new ArrayList<Order>();
}

@Entity
public class Product {
    @Id @Column(name = "PRODUCT_ID")
    private String id;

    private String name;
}
```

```java
// 저장 방법
public void save() {
    Member member1 = new Member();
    member1.setId("member1");
    member1.setUsername("회원1");
    em.persist(member1);

    Product productA = new Product();
    productA.setId("productA");
    productA.setName("상품");
    em.persist(productA);

    Order order = new Order();
    order.setMember(member1);
    order.setProduct(productA);
    order.setOrderAmount(2);
    em.persist(order);
}

// 조회 방법
public void find() {
    Long orderId = 1L;
    Order order = em.find()

    Member member = order.getMember();
    Product product = order.getProduct();
}
```

### 6.4.5 다대다 연관관계 정리
- 식별관계 : 받아온 식별자를 기본키 + 외래키로 사용
- 비식별관계 : 받아온 식별자는 외래 키로만 사용하고 새로운 식별자를 추가

- 복합키 = 식별관계
- 대리키 + 유니크 제약 = 비식별관계

- 비식별 관계를 실무에서는 더 사용하는 편


# 함께 이야기 해볼만한 것

- 실무에서 양방향을 쓸 만한 곳이 있을까?
    - 단방향을 쓰는 것을 더 추천하는 것 같긴 함.
- ManyToMany 는 쓰지 않고 다대일을 쓰는게 더 좋을것 같은데 다른 분들은 어떠신지?
    - 컬럼이 추가되지 않을거라는 보장이 없으므로...
- 연관관계 편의 메서드는 엔티티에 두는게 좋을 것 같긴 한데 어떻게 생각하시는지?