# 4장. 엔티티 매핑

- 객체와 테이블 매핑 : @Entity, @Table
- 기본 키 매핑 : @Id
- 필드와 컬럼 매핑 : @Column
- 연관관계 매핑 : @ManyToOne, @JoinColumn

## 4.1 @Entity

- @Entity 어노테이션은 JPA 를 사용해서 테이블과 매핑할 클래스는 무조건 붙여야한다.
- @Entity 사용 시 주의점
  - 기본 생성자는 필수
  - final 클래스, enum, interface, inner 클래스는 사용 불가
  - 저장할 필드에 final 붙이면 안됨

## 4.2 @Table

- 엔티티와 매핑할 테이블을 지정
- 속성
  - name : 매핑할 테이블 이름
  - catalog : catalog 기능이 있을 경우 매핑
  - schema : schema 기능이 있을 경우 매핑
  - uniqueConstraints : DDL 생성 시 유니크 제약조건을 만든다. 스키마 자동 생성 기능을 이용할 때만 사용됨

## 4.3 다양한 매핑 사용

```java
@Entity
@Table(name = "MEMBER")
public class Member {
  @Id
  @Column(name = "ID")
  private String id;

  @Column(name = "NAME")
  private String username;

  private Integer age;

  // 추가된 필드
  @Enumerated(EnumType.STRING)
  private RoleType roleType;

  @Temporal(TemporalType.TIMESTAMP)
  private Date createdDate;

  @Temporal(TemporalType.TIMESTAMP)
  private Date lastModifiedDate;

  @Lob
  private String description;
}
```

- enum 을 사용하려면 @Enumerated 를 사용해야한다.
- 날짜 타입은 @Temporal 을 사용해서 매핑한다.
- description 의 경우 길이 제한이 없으므로 CLOB 타입으로 저장한다. @Lob 은 CLOB, BLOB 타입을 매핑할 수 있다.

## 4.4 데이터베이스 스키마 자동 생성

- hibernate.hdb2ddl.auto = create 이 속성을 사용하면 애플리케이션 실행 시점에 데이터베이스 테이블을 자동으로 생성
- _(개인적인 의견)_

  - Spring Data JPA 의 경우 `spring.jpa.hibernate.ddl-auto=create` 옵션을 사용
  - 또는 `spring.sql.init.mode: always` 를 이용해 schema.sql, data.sql 을 실행하게 할 수도 있다.

### 이름 매핑 전략 변경하기

- Spring boot 2.x 이상 부터는 따로 설정 안해도 언더스코어로 나오게 되어 있다.

## 4.5 DDL 생성 기능

- DDL 에 제약조건을 추가해보자

```java
@Entity
@Table(name="MEMBER")
public class Member {
  @Id
  @Column(name = "ID")
  private String id;

  @Column(name = "NAME", nullable = false, length = 10)
  private String username;
}
```

```SQL
create table MEMBER {
  ID varchar(255) not null
  NAME varchar(10) not null
  ...
}
```

- 유니크 제약조건 uniqueConstraints 도 써보자.

```java
@Entity(name = "Member")
@Table(name = "MEMBER", unqueConstraints = {@UniqueConstraint(
  name = "NAME_AGE_UNIQUE",
  columnNames = {"NAME", "AGE"}
)})
```

```SQL
ALTER TABLE MEMBER
  ADD CONSTRAINT NAME_AGE_UNIQUE UNIQUE (NAME, AGE)
```

- DDL 을 생성할 떄만 사용되고 실제 JPA 실행 로직에는 영향을 주지 않는다.

## 4.6 기본 키 매핑

- @Id 어노테이션을 이용해 기본 키 매핑을 했다. AUTO_INCREMENT 같은 기능을 사용해 기본키로 쓰려면 어떻게 해야할까?
- JPA 가 제공하는 데이터베이스 기본 키 생성 전략

  - 직접 할당 : 기본 키를 애플리케이션에서 직접 할당
  - 자동 생성 : 대리 키 사용 방식
    - IDENTITY: 기본키 생성을 DB에 위임
    - SEQUENCE: DB의 시퀀스를 사용해서 기본키 할당
    - TABLE: 키 생성 테이블 사용

- 직접 할당 시 AUTO_INCREMENT 를 쓰려면 @GeneratedValue 를 쓰면 된다.
- 저자가 이야기 한 hibernate.id.new_generator_mappings 는 기본값이 true로 바뀌었다고 한다.

### 4.6.1 기본 키 직접 할당 전략

- @Id 로 매핑

### 4.6.2 IDENTITY 전략

- 키 생성을 데이터베이스에 위임
- AUTO_INCREMENT 로 테이블을 설정한 뒤에 id 에 null을 넣어주면 DB가 값을 채워준다.

```java
@Id
@GeneratedValue(strategy=GenerationType.IDENTITY)
private long id;
```

- 위 설정을 해줘야한다.
- 이 전략은 키 생성이 DB에서 이루어지기 때문에 Transaction 을 지원하는 쓰기 지연이 동작하지 않는다.

### 4.6.3 SEQUENCE 전략

- 시퀀스 매핑

```java
@Entity
@SequenceGenerator(
  name = "BOARD_SEQ_GENERATOR",
  sequenceName = "BOARD_SEQ",
  initialValue = 1, allocationSize = 1
)
public class Board {
  @Id
  @GeneratedValue(strategy = GenerationType.SEQUENCE, generator="BOARD_SEQ_GENERATOR")
  private long id;
}
```

- 실제 DB의 시퀀스와 매핑한다.
- 시퀀스는 IDENTITY 와 코드는 같지만 내부 동작은 다르다.
- 시퀀스의 경우 em.persist() 를 호출할 때 데이터베이스의 식별자를 조회한다. 조회한 식별자를 엔티티에 할당 후에 영속성 컨텍스트에 저장한다.

#### @SequenceGenerator

- name: 식별자 생성기 이름
- sequenceName: DB에 등록된 시퀀스 이름
- initialValue: DDL 생성 시에만 사용
- allocationSize: 시퀀스 한번 호출에 증가하는 수 / 기본값 50

  - 기본값이 50 이므로 DB에서 1씩 증가하게 되어 있다면 변경이 필요함

- _(개인적인 의견)_
  - 어떤걸 취하는 것이 좋을까?
    - DB에 따라 다를 것 같음. MYSQL 의 경우 auto_increment 로 인해 identity 를 사용할 것이고,
    - Postgresql 은 시퀀스 사용이 되기에 SEQUENCE 를 쓸 수 있을것.
    - sequence 는 new_generator_mappings 를 true 로 설정해야 최적화가 되기 때문에 Postgresql 을 쓰면 Sequence 를 쓰는게 좋지 않을까? -> 성능 상 유리해보임

### 4.6.4 TABLE 전략

- 키 생성 전용 테이블을 생성한 뒤에 DB 시퀀스를 흉내내는 전략

### 4.6.5 AUTO 전략
