# 7장 고급 매핑

- 상속 관계 매핑
- @MappedSuperclass
- 복합 키와 식별 관계 매핑
- 조인 테이블
- 엔티티 하나에 여러 테이블 매핑하기

## 7.1 상속 관계 매핑
- 관계형 데이터베이스에는 객체지향에서 다루는 상속이라는 개념이 없다. 

- 각각의 테이블로 변환
- 통합 테이블로 변환
- 서브타입 테이블로 변환

### 7.1.1 조인 전략
- 엔티티를 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아 기본키 + 외래키로 사용하는 전략
- 테이블은 타입의 개념이 없기 때문에 DTYPE 컬럼을 구분 컬럼으로 사용

```java
@Entity
@Inheritance(strategy=InheritanceType.JOINED)
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item {
    @Id @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;

    private String name;
    private int price;
}

@Entity
@DiscriminatorValue("A")
public class Album extends Item {
    private String artist;
}

@Entity
@DiscriminatorValue("M")
public class Movie extends Item {
    private String director;
    private String actor;
}
```

- @Inheritance 의 경우 상속 매핑을 조인 전략으로 쓰도록 설정
- @DiscriminatorColumn 의 경우 부모 클래스에 구분 컬럼을 지정. 자식 테이블을 구분할 수 있다. 

- @PrimaryKeyJoinColumn 을 쓰면 자식 테이블의 기본키 컬럼명을 변경할 수 있다. 

```java
@Entity
@DiscriminatorValue("B")
@PrimaryKeyJoinColumn(name = "BOOK_ID")
public class Book extends Item {
    private String author;
    private String isbn;
}
```

- BOOK 테이블의 ITEM_ID 기본키 컬럼을 BOOK_ID 로 변경했다. 

- 장점
    - 테이블이 정규화됨
    - 외래 키 참조 무결성 제약조건을 활용할 수 있다.
    - 저장공간을 효율적으로 사용한다.

- 단점
    - 조회할 때 조인이 많이 사용되므로 성능이 저하될 수 있다.
    - 조회 쿼리가 복잡하다.
    - 데이터를 등록할 때 INSERT SQL 을 두 번 실행한다. 

### 7.1.2 단일 테이블 전략
- 테이블 하나만 사용한다. 
- 조회할 때 가장 빠르다. 
- 주의점 : 자식 엔티티가 매핑한 컬럼은 모두 null 허용이어야 한다는 점


```java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item {
    @Id @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;
    private String name;
    private int price;
}

@Entity
@DiscriminatorColumn("A")
public class Album extends Item {}

@Entity
@DiscriminatorColumn("M")
public class Movie extends Item {}

@Entity
@DiscriminatorColumn("B")
public class Book extends Item {}
```

- 장점
    - 조인이 필요 없으므로 조회 성능이 빠름
    - 조회 쿼리가 단순

- 단점
    - 자식 엔티티가 매핑한 컬럼은 모두 null 허용
    - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있음, 상황에 따라 조회 성능이 느려질 수 있음

- 특징
    - 구분 컬럼을 꼭 사용해야함

### 7.1.3 구현 클래스마다 테이블 전략
- 자식 엔티티마다 테이블을 만든다. 

```java
@Entity
@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)
public abstract class Item {
    @Id @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;

    private String name;
    private int price;
}

@Entity
public class Album extends Item {}

@Entity
public class Movie extends Item {}

@Entity
public class Book extends Item {}
```

- 장점
    - 서브 타입을 구분해서 처리할 때 효과적
    - not null 제약조건을 사용할 수 있음
- 단점
    - 여러 자식 테이블을 함께 조회할 때 성능이 느림
    - 자식 테이블을 통합해서 쿼리하기 어려움
- 특징
    - 구분 쿼리를 사용하지 않음

## 7.2 @MappedSuperclass
- 부모 클래스를 상속받는 자식 클래스에게 매핑 정보만 제공하고 싶다면 @MappedSuperclass 를 쓰면 된다. 

```java
@MappedSuperclass
public abstract class BaseEntity {
    @Id @GeneratedValue
    private Long id;
    private String name;
}

@Entity
public class Member extends BaseEntity {
    // ID 상속
    // name 상속
    private String email;
}

@Entity
public class Seller extends BaseEntity {
    private String shopName;
}
```

- BaseEntity 에는 객체들이 주로 쓰는 공통 매핑 정보를 정의
- 매핑 정보 재정의를 할 때는 @AttributeOverrides 나 @AttributeOverride 를 사용
- 연관관계 재정의는 @AssociationOverrides, @AssociationOverride 를 사용

```java
@Entity
@AttribeOverride(name = "id", column = @Column(name = "MEMBER_ID"))
public class Member extends BaseEntity {}

```

- id 속성의 컬럼명을 MEMBER_ID 로 재정의 했다. 

## 7.3 복합 키와 식별 관계 매핑
### 7.3.1 식별 관계 vs. 비식별 관계

- 식별 관계
    - 부모 테이블의 기본 키를 내려받아 자식 테이블의 기본키 + 외래 키로 사용하는 관계

- 비식별 관계
    - 부모 테이블의 기본키를 받아 자식 테이블의 외래 키로만 사용

- 필수적 비식별 관계 : 외래 키에 NULL을 허용하지 않음, 연관관계를 필수적으로 맺어야함
- 선택적 비식별 관계 : 외래 키에 NULL을 허용, 연관관계를 맺을지 말지 선택 가능

### 7.3.2 복합 키 : 비식별 관계 매핑

- JPA 는 복합키를 제공하기 위해 @IdClass, @EmbeddedId 2가지 방법을 제공한다. 

#### @IdClass

```java
// 부모 클래스
@Entity
@IdClass(ParentId.class)
public class Parent {
    @Id
    @Column(name = "PARENT_ID1")
    private String id1; // ParentId.id1과 연결

    @Id
    @Column(name = "PARENT_ID2")
    private String id2; // ParentId.id2 와 연결

    private String name;
}

// 식별자 클래스
public class ParentId implements Serializable {
    private String id1;
    private String id2;

    public ParentId() {}

    public ParentId(String id1, String id2) {
        this.id1 = id1;
        this.id2 = id2;
    }

    @Override
    public boolean equals(Object o) {}

    @Override
    public int hashCode() {}
}
```

- 식별자 클래스의 속성명과 엔티티에서 사용하는 식별자의 속성명이 같아야 한다. 
- Serializable 인터페이스를 구현해야 한다.
- equals, hashCode 를 구현해야 한다.
- 기본 생성자가 있어야 한다. 
- 식별자 클래스는 public 이어야 한다. 

- 사용 예

```java
Parent parent = new Parent();
parent.setId1("myId1");
parent.setId2("myId2");
parent.setName("parentName");
em.persist(parent);
```

- ParentId 클래스가 보이지 안흔데, em.persist() 를 호출하면 내부적으로 식별자 클래스인 ParentId를 생성하고 영속성 컨텍스트의 키로 사용한다. 

- 복합키로 조회하기 

```java
ParentId parentId = new ParentId("myId1", "myId2");
Parent parent = em.find(Parent.class, parentId);
```

```java
// 자식 클래스
@Entity
public class Child {
    @Id
    private String id;

    @ManyToOne
    @JoinColumns({
        @JoinColumn(name = "PARENT_ID1", referencedColumnName = "PARENT_ID1")
        @JoinColumn(name = "PARENT_ID2", referencedColumnName = "PARENT_ID2")
    })
    private Parent parent;
}
```

- 부모 테이블의 기본 키 컬럼이 복합키 이므로 자식 테이블의 외래 키도 복합키다. 
- JoinColumns 를 써서 조인해야한다. 

#### @EmbeddedId
- 좀더 객체지향적인 방법

```java
@Entity
public class Parent {
    @EmbeddedId
    private Parent id;
    private String name;
}

@Embeddable
public class ParentId implements Serializable {
    @Column(name = "PARENT_ID1")
    private String id1;

    @Column(name = "PARENT_ID2")
    private String id2;
}
```

- 식별자 클래스에 기본키를 직접 매핑한다. 
- @Embeddable 을 쓰기 위한 조건
    - @Embeddable 어노테이션을 붙인다.
    - Serializable 인터페이스를 구현
    - equals, hashCode 구현
    - 기본 생성자가 있어야함
    - 식별자 클래스는 public 이어야 함

- 사용 예
```java
Parent parent = new Parent();
ParentId parentId = new ParentId("myId1", "myId2");
parent.setId(parentId);
parent.setName("parentName");
em.persist(parent);

// 엔티티 조회
ParentId parentId = new ParentId("myId1", "myId2");
Parent parent = em.find(Parent.class, parentId);
```

#### 복합키와 equals(), hashCode()
- 복합키는 필수로ㅗ 두가지를 구현해야한다. 

```java
ParentId id1 = new ParentId();
id1.setId1("myId1");
id1.setId2("myId2");

ParentId id2 = new ParentId();
id2.setId1("myId1");
id2.setId2("myId2");

id1.equals(id2) -> ?
```

- 두개의 인스턴스는 다르기 때문에 결과는 거짓이다. (동일성 비교를 하기 때문)
- 영속성 컨텍스트는 엔티티의 식별자를 키로 사용해 엔티티를 관리한다. 식별자를 비교할 때 equals, hashCode 를 쓴다. 

#### @IdClass vs. @EmbeddedId
- 각각 장단점이 있기 때문에 취향에 맞게 쓰면 된다. 
- 특정 상황에서 EmbeddedId 가 JPQL이 조금 더 길어질 수 있다. 

```java
em.createQuery("select p.id.id1, p.id.id2 from Parent p"); // @EmbeddedId
em.createQuery("select p.id1, p.id2 from Parent p");    // @IdClass
```

### 7.3.3 복합키 : 식별 관계 매핑

#### @IdClass 와 식별 관계

```java
@Entity
public class Parent {
    @Id @Column(name = "PARENT_ID")
    private String id;
    private String name;
}

@Entity
@IdClass(ChildId.class)
public class Child {
    @Id
    @ManyToOne
    @JoinColumn(name = "PARENT_ID")
    public Parent parent;

    @Id @Column(name = "CHILD_ID")
    private String childId;

    private String name;
}

public class ChildId implements Serializable {
    private String parent;
    private String childId;
}

@Entity
@IdClass(GrandChildId.class)
public class GrandChild {
    @Id
    @ManyToOne
    @JoinColumns({
        @JoinColumn(name = "PARENT_ID"),
        @JoinColumn(name = "CHILD_ID")
    })
    private Child child;

    @Id @Column(name = "GRANDCHILD_ID")
    private String id;
    private String name;
}

public class GrandChildId implements Serializable {
    private ChildId child;
    private String id;
}
```

### 7.3.4 비식별 관계로 구현

```java
@Entity
public class Parent {
    @Id @GeneratedValue
    @Column(name = "PARENT_ID")
    private Long id;
    private String name;
}

@Entity
public class Child {
    @Id @GeneratedValue
    @Column(name = "CHILD_ID")
    private Long id;
    private String name;

    @ManyToOne
    @JoinColumn(name = "PARENT_ID")
    private Parent parent;
}

@Entity
public class Child {
    @Id @GeneratedValue
    @Column(name = "GRANDCHILD_ID")
    private Long id;
    private String name;

    @ManyToOne
    @JoinColumn(name = "CHILD_ID")
    private Parent parent;
}
```

### 7.3.5 일대일 식별관계

```java
@Entity
public class Board {
    @Id @GeneratedValue
    @Column(name = "BOARD_ID")
    private Long id;

    private String title;

    @OneToOne(mappedBy = "board")
    private BoardDetail boardDetail;
}

@Entity
public class BoardDetail {
    @Id
    private Long boardId;

    @MapsId         // BoardDetail.boardId 매핑
    @OneToOne
    @JoinColumn(name = "BOARD_ID")
    private Board board;

    private String content;
}

// 저장
public void save() {
    Board board = new Board();
    board.setTitle("제목");
    em.persist(board);

    BoardDetail boardDetail = new BoardDetail();
    boardDetail.setContent("내용");
    boardDetail.setBoard(board);
    em.persist(boardDetail);
}
```

### 7.3.6 식별, 비식별 관계의 장단점
 - 식별관계는 부모 테이블의 기본 키를 자식 테이블로 전파하며 자식 테이블의 기본키 컬럼이 점점 늘어남
 - 결국 SQL이 복잡해지고 기본키 인덱스가 불필요하게 커질 수 있음
 - 2개 이상 컬럼을 합해 복합 기본키를 만들어야 하는 경우가 많음
 - 식별관계는 비즈니스 의미가 있는 자연키를 조합하는데 이 부분은 시간이 지나면 바뀐다. 
 - 비식별관계는 비즈니스와 전혀 관계없는 대리키를 사용한다.


#### 결론
- 비식별관계를 사용하고 기본 키는 Long 타입의 대리 키를 사용하는 것이 좋다.

## 7.4 조인 테이블
- 조인 컬럼 사용 (외래 키)
- 조인 테이블 사용 (테이블 사용)

### 7.4.1 일대일 조인 테이블
- 일대일 관계를 만들려면 조인 테이블의 외래 키 컬럼 각각에 2개의 유니크 제약조건을 걸어야 한다. 

```java
@Entity
public class Parent {
    @Id @GeneratedValue
    @Column(name = "PARENT_ID")
    private Long id;
    private String name;

    @OneToOne
    @JoinTable(name = "PARENT_CHILD",
        joinColumns = @JoinColumn(name = "PARENT_ID"), 
        inverseJoinColumn = @JoinColumn(name = "CHILD_ID"))
    private Child child; 
}

@Entity
public class Child {
    @Id @GeneratedValue
    @Column(name = "CHILD_ID")
    private Long id;
    private String name;
}
```

- @JoinTable 어노테이션
    - name : 매핑할 조인 테이블 이름
    - joinColumns : 현재 엔티티를 참조하는 외래 키
    - inverseJoinColumn : 반대방향 엔티티를 참조하는 외래 키

- 양방향 매핑을 하려면 아래 코드를 추가한다.
```java
public class Child {
    @OneToOne(mappedBy = "child")
    private Parent parent;
}
```

### 7.4.2 일대다 조인 테이블

```java
@Entity
public class Parent {
    @Id @GeneratedValue
    @Column(name = "PARENT_ID")
    private Long id;
    private String name;

    @OneToMany
    @JoinTable(name = "PARENT_CHILD",
        joinColumns = @JoinColumn(name = "PARENT_ID"), 
        inverseJoinColumn = @JoinColumn(name = "CHILD_ID"))
    private List<Child> child = new ArrayList<Child>(); 
}

@Entity
public class Child {
    @Id @GeneratedValue
    @Column(name = "CHILD_ID")
    private Long id;
    private String name;
}
```

### 7.4.3 다대일 조인 테이블
```java
@Entity
public class Parent {
    @Id @GeneratedValue
    @Column(name = "PARENT_ID")
    private Long id;
    private String name;

    @OneToMany(mappedBy = "parent")
    private List<Child> child = new ArrayList<Child>(); 
}

@Entity
public class Child {
    @Id @GeneratedValue
    @Column(name = "CHILD_ID")
    private Long id;
    private String name;

    @ManyToOne(optional = false)
    @JoinTable(name = "PARENT_CHILD",
        joinColumns = @JoinColumn(name = "CHILD_ID"), 
        inverseJoinColumn = @JoinColumn(name = "PARENT_ID"))
    private Parent parent;
}
```

### 7.4.4 다대다 조인 테이블
```java
@Entity
public class Parent {
    @Id @GeneratedValue
    @Column(name = "PARENT_ID")
    private Long id;
    private String name;

    @ManyToMany
    @JoinTable(name = "PARENT_CHILD",
        joinColumns = @JoinColumn(name = "PARENT_ID"), 
        inverseJoinColumn = @JoinColumn(name = "CHILD_ID"))
    private List<Child> child = new ArrayList<Child>(); 
}

@Entity
public class Child {
    @Id @GeneratedValue
    @Column(name = "CHILD_ID")
    private Long id;
    private String name;
}
```

## 7.5 엔티티 하나에 여러 테이블 매핑
```java
@Entity
@Table(name = "BOARD")
@SecondaryTable(name = "BOARD_DETAIL",
    pkJoinColumns = @PrimaryKeyJoinColumn(name = "BOARD_DETAIL_ID"))
public class Board {
    @Id @GeneratedValue
    @Column(name = "BOARD_ID")
    private Long id;

    private String title;

    @Column(table = "BOARD_DETAIL")
    private String content;
}
```

- @SecondaryTable 을 통해 테이블을 추가 매핑할 수 있다. 
- name 속성 : 매핑할 다른 테이블의 이름
- pkJoinColumns : 매핑할 다른 테이블의 기본 키 컬럼 속성
- content 필드는 BOARD_DETAIL 테이블의 컬럼에 매핑했다. 
- 결론
    - 하나의 엔티티에 하나의 테이블을 매핑하는 것이 낫다. 