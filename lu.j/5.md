# 5 장. 연관관계 매핑 기초

- 객체의 참조와 테이블의 외래 키를 매핑하는 것이 이 장의 목표

## 5.1 장 단방향 연관관계

- N:1 (다대일) 단방향 관계
    - 회원과 팀이 있다.
    - 회원은 하나의 팀에만 소속될 수 있다.
    - 회원과 팀은 다대일 관계다. 

- 객체의 연관관계
    - 회원 객체는 Member.team 필드로 팀 객체와 연관관계
    - 회원 객체와 팀 객체는 단방향 관계
    - 팀은 회원을 알 수가 없다. 

- 테이블 연관관계
    - 회원 테이블은 TEAM_ID 외래 키로 팀 테이블과 연관관계를 맺음
    - 회원 테이블과 팀 테이블은 양방향 관계

- 객체 연관관계와 테이블 연관관계의 가장 큰 차이
    - 참조를 통한 연관관계는 언제나 단방향
    - 양방향 관계가 아니라 서로 다른 단방향 관계 2개

    - 단방향 관계
    ```java
    class A {
        B b;
    }
    class B {}
    ```
    - 양방향 연관관계
    ```java
    class A {
        B b;
    }
    class B {
        A a;
    }
    ```

- 객체 연관관계 vs. 테이블 연관관계 정리
    - 객체는 참조(주소)로 연관관계를 맺음
    - 테이블은 외래키로 맺음
    - 객체를 양방향 참조 하려면 단방향 연관관계를 2개 만들어야함

### 5.1.1 순수한 객체 연관관계
- 순수하게 객체만 사용한 연관관계를 살펴보자

```java
public class Member {
    private String id;
    private String username;

    private Team team; // 팀의 참조 보관

    private void setTeam(Team team) {
        this.team = team;
    }
}

public class team {
    private String id;
    private String name;
}

public static void main(String[] args) {
    Member member1 = new Member("member1", "회원1");
    Member member2 = new Member("member2", "회원2");

    Team team1 = new Team("team1", "팀1");

    member1.setTeam(team1);
    member2.setTeam(team1);

    Team findTeam = member1.getTeam();
} 
```

### 5.1.2 테이블 연관관계

```SQL
CREATE TABLE MEMBER (
    MEMBER_ID VARCHAR(255) NOT NULL,
    TEAM_ID VARCHAR(255),
    USERNAME VARCHAR(255),
    PRIMARY KEY (MEMBER_ID)
)
CREATE TABLE TEAM (
    TEAM_ID VARCHAR(255) NOT NULL,
    NAME VARCHAR(255),
    PRIMARY KEY (TEAM_ID)
)

ALTER TABLE MEMBER ADD CONSTRAINT FK_MEMBER_TEAM
    FOREIGN KEY (TEAM_ID)
    REFERENCES TEAM
```

### 5.1.3 객체 관계 매핑

```java
@Entity
public class Member {
    @Id
    @Column(name = "MEMBER_ID")
    private String id;

    private String username;

    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team;

    public void setTeam(Team team) {
        this.team = team;
    }
}

@Entity
public class Team {
    @Id
    @Column(name = "TEAM_ID")
    private String id;

    private String name;
}
```

- @ManyToOne : 이름 그대로 다대일 관계라는 매핑 정보
- @JoinColumn: 조인 컬럼은 외래키 매핑 시에 사용한다. 


### 5.1.4 @JoinColumn
- name : 매핑할 외래키 명칭
- referencedColumnName : 외래 키가 참조하는 대상 테이블 컬럼 명
- foreignKey(DDL) : 외래키 제약조건을 설정할 수 있다. 


### 5.1.5 @ManyToOne
- optional : false 로 설정하면 연관된 엔티티가 항상 있어야함. (기본값 true)
- fetch : @ManyToOne - FetchType.EAGER, @OneToMany - FetchType.LAZY
    - 글로벌 패치 전략을 설정
- cascade : 영속성 전이 기능 사용
- targetEntity : 연관된 엔티티 타입 정보 설정

```java
@OneToMany
private List<Member> members;   // 제네릭으로 타입 정보를 알 수 있다.

@OneToMany(targetEntity=Member.class)
private List members;           // 제네릭이 없으면 타입 정보를 알 수 없다. 
```

## 5.2 연관관계 사용

### 5.2.1 저장
```java
public void testSave() {
    Team team1 = new Team("team1", "팀1");
    em.persist(team1);

    Member member1 = new Member("member1", "회원1");
    member1.setTeam(team1);
    em.persist(member1);

    Member member2 = new Member("member2", "회원2");
    member2.setTeam(team1);
    em.persist(member2);
}
```

### 5.2.2 조회
- 연관관계 엔티티 조회 방법
    - 객체 그래프 탐색 (객체 연관관계를 사용한 조회)
    - 객체지향 쿼리 사용(JPQL)

- 객체 그래프 탐색

```java
Member member = em.find(Member.class, "member1");
Team team = member.getTeam();
```

- 객체지향 쿼리 사용

```java
private static void queryLogicJoin(EntityManager em) {
    String jpql = "select m from Member m join m.team t where "+
        "t.name=:teamName";

    List<Member> resultList = em.createQuery(jpql, Member.class)
        .setParameter("teamName", "팀1")
        .getResultList();

    for (Member member : resultList) {
        System.out.println("[query] member.username = " + 
            member.getUsername());
    }
}
```

### 5.2.3 수정
```java
private static void updateRelation(EntityManager em) {
    Team team2 = new Team("team2", "팀2");
    em.persist(team2);

    Member member = em.find(Member.class, "member1");
    member.setTeam(team2);
}
```

### 5.2.4 연관관계 제거
```java
private static void deleteRelation(EntityManager em) {
    Member member1 = em.find(Member.class, "member1");
    member1.setTeam(null);
}
```

### 5.2.5 연관된 엔티티 삭제
```java
member1.setTeam(null);
member2.setTeam(null);
em.remove(team);
```

## 5.3 양방향 연관관계

### 5.3.1 양방향 연관관계 매핑

```java
@Entity
public class Member {
    @Id
    @Column(name = "MEMBER_ID")
    private String id;

    private String username;

    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team;

    public void setTeam(Team team) {
        this.team = team;
    }
}

@Entity
public class Team {
    @Id
    @Column(name = "TEAM_ID")
    private String id;

    private String name;

    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<Member>();
}
```

### 5.3.2 일대다 컬렉션 조회

```java
public void biDirection() {
    Team team = em.find(Member.class, "team1");
    List<Member> members = team.getMembers();

    for (Member member : members) {
        System.out.println("member.username = " + 
            member.getUsername());
    }
}
```

## 5.4 연관관계의 주인
- mappedBy 가 필요한 이유는? 
    - 객체에는 양방향 연관관계가 없음

- 테이블은 외래키 하나로 두 테이블의 연관관계를 관리함
- 엔티티를 단방향으로 매핑하면 참조를 하나만 사용
- 엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래 키는 하나
- 두 객체의 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야하는데 이것을 연관관계의 주인(Owner)라고 한다. 

### 5.4.1 양방향 매핑 규칙 : 연관관계의 주인
- 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 외래키를 관리할 수 있다. 
- 주인이 아닌 쪽은 read 만 가능
- 연관관계의 주인을 정한다는 것은 사실 외래 키 관리자를 선택하는 것이다. 

### 5.4.2 연관관계의 주인은 외래 키가 있는 곳
- 데이터베이스 테이블의 다대일, 일대다 관계에서는 항상 다 쪽이 외래키를 가진다. @ManyToOne 이 연관관계의 주인이 되므로 이 어노테이션에 mappedBy 를 설정 할 수 없다. 속성도 없다. 

## 5.5 양방향 연관관계 저장
```java
public void testSave() {
    Team team1 = new Team("team1", "팀1");
    em.persist(team1);

    Member member1 = new Member("member1", "회원1");
    member1.setTeam(team1);
    em.persist(member1);

    Member member2 = new Member("member2", "회원2");
    member2.setTeam(team1);
    em.persist(member2);
}
```

- 단방향 연관관계의 코드와 완전히 같다. 
- `team1.getMembers().add(member1)` 같은 코드가 추가로 있어야 할 것 같지만, 연관관계의 주인이 아니다.
- `member1.setTeam(team1)` Member.team은 연관관계의 주인이다. 

## 5.6 양방향 연관관계의 주의점
- 연관관계의 주인에는 값을 입력하지 않고 주인이 아닌 곳에만 입력하는 실수가 많다. 
- 데이터베이스에 외래키 값이 정상적으로 저장되지 않으면 이것부터 의심해보자

```java
public void testSaveNonOwner() {
    Member member1 = new Member("member1", "회원1");
    em.persist(member1);

    Member member2 = new Member("member2", "회원2");
    em.persist(member2);

    Team team1 = new Team("team1", "팀1");
    team1.getMembers().add(member1);
    team1.getMembers().add(member2);
    
    em.persist();
}
```

- member 에 setTeam을 해주지 않아서 team id 가 null로 저장되어 버린다. 
- 연관관계의 주인만이 외래 키의 값을 변경할 수 있다. 

### 5.6.1 순수한 객체까지 고려한 양방향 연관관계
- 객체 관점에서 양쪽 방향에 모두 값을 입력해주는 것이 가장 안전

```java
public void test순수한객체_양방향() {
    Team team1 = new Team("team1", "팀1");
    Member member1 = new Member("member1", "회원1");
    Member member2 = new Member("member2", "회원2");

    member1.setTeam(team1);
    member2.setTeam(team1);

    List<Member> members = team.getMembers();
    System.out.println("members size = " + members.size());
    // members.size = 0
}
```

- JPA 를 쓰지 않은 순수한 객체

- 아래는 양방향 모두 설정한 코드

```java
public void test순수한객체_양방향() {
    Team team1 = new Team("team1", "팀1");
    Member member1 = new Member("member1", "회원1");
    Member member2 = new Member("member2", "회원2");

    member1.setTeam(team1);
    team.getMembers().add(member1);

    member2.setTeam(team1);
    team.getMembers().add(member2);

    List<Member> members = team.getMembers();
    System.out.println("members size = " + members.size());
    // members.size = 2
}
```

- JPA 를 써서 완성한 코드

```java
public void testORM_양방향() {
    Team team1 = new Team("team1", "팀1");
    em.persist(team1);

    Member member1 = new Member("member1", "회원1");
    member1.setTeam(team1);
    team.getMembers().add(member1);

    em.persist(member1);

    Member member2 = new Member("member2", "회원2");

    member2.setTeam(team1);
    team.getMembers().add(member2);
    em.persist(member2);
}
```

- 결론 : 객체의 양방향 연관관계는 양쪽 모두 관계를 맺어주자. 
- *(개인적인 의견)*
    - JPA 를 쓰더라도 즉시 메모리 업데이트를 위해서는 add 를 해주는 것이 좋음.

### 5.6.2 연관관계 편의 메소드
- 양방향 연관관계는 결국 양쪽 다 신경써야한다. 

```java
public void setTeam(Team team) {
    this.team = team;
    team.getMembers().add(this);        // 이쪽에 코드 추가
}

public void testORM_양방향_리팩토링() {
    Team team1 = new Team("team1", "팀1");
    Member member1 = new Member("member1", "회원1");
    Member member2 = new Member("member2", "회원2");

    member1.setTeam(team1);
    team.getMembers().add(member1);
    em.persist(member1);

    member2.setTeam(team1);
    team.getMembers().add(member2);
    em.persist(member2);
}
```

- 위처럼 하는 것이 실수를 줄이는데 도움이 될 수 있다. 

### 5.6.3 연관관계 편의 메소드 작성 시 주의사항
- setTeam() 메소드에 버그가 있다. 
- 다른 연관관계로 변경할 수 있기 때문에 기존 연관관계를 제거하는 코드를 추가해야한다.

```java
public void setTeam(Team team) {
    if (this.team != null) {
        this.team.getMembers().remove(this);
    }
    this.team = team;
    team.getMembers().add(this);
}
```

## 5.7 정리
- 단방향 매핑과 비교해서 양방향 매핑은 복잡하다. 
- 양방향 매핑의 장점은 반대방향으로 객체 그래프 탐색 기능이 추가된 것 뿐이다. 

- 단방향 매핑 만으로 테이블과 객체의 연관관계 매핑은 이미 완료
- 단방향을 양방향으로 만들면 반대방향으로 객체 그래프 탐색 기능이 추가됨
- 양방향 연관관계를 매핑하려면 객체에서 양쪽 방향을 모두 관리해야 함
